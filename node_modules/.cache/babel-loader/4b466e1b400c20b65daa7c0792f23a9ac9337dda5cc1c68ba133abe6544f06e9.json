{"ast":null,"code":"import { Vector3 } from \"three\";\nclass STLExporter {\n  parse(scene) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options = Object.assign({\n      binary: false\n    }, options);\n    const binary = options.binary;\n    const objects = [];\n    let triangles = 0;\n    scene.traverse(function (object) {\n      if (object.isMesh) {\n        const geometry = object.geometry;\n        const index = geometry.index;\n        const positionAttribute = geometry.getAttribute(\"position\");\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3;\n        objects.push({\n          object3d: object,\n          geometry\n        });\n      }\n    });\n    let output;\n    let offset = 80;\n    if (binary === true) {\n      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4;\n      const arrayBuffer = new ArrayBuffer(bufferLength);\n      output = new DataView(arrayBuffer);\n      output.setUint32(offset, triangles, true);\n      offset += 4;\n    } else {\n      output = \"\";\n      output += \"solid exported\\n\";\n    }\n    const vA = new Vector3();\n    const vB = new Vector3();\n    const vC = new Vector3();\n    const cb = new Vector3();\n    const ab = new Vector3();\n    const normal = new Vector3();\n    for (let i = 0, il = objects.length; i < il; i++) {\n      const object = objects[i].object3d;\n      const geometry = objects[i].geometry;\n      const index = geometry.index;\n      const positionAttribute = geometry.getAttribute(\"position\");\n      if (index !== null) {\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0);\n          const b = index.getX(j + 1);\n          const c = index.getX(j + 2);\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      } else {\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0;\n          const b = j + 1;\n          const c = j + 2;\n          writeFace(a, b, c, positionAttribute, object);\n        }\n      }\n    }\n    if (binary === false) {\n      output += \"endsolid exported\\n\";\n    }\n    return output;\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a);\n      vB.fromBufferAttribute(positionAttribute, b);\n      vC.fromBufferAttribute(positionAttribute, c);\n      if (object.isSkinnedMesh === true) {\n        object.applyBoneTransform(a, vA);\n        object.applyBoneTransform(b, vB);\n        object.applyBoneTransform(c, vC);\n      }\n      vA.applyMatrix4(object.matrixWorld);\n      vB.applyMatrix4(object.matrixWorld);\n      vC.applyMatrix4(object.matrixWorld);\n      writeNormal(vA, vB, vC);\n      writeVertex(vA);\n      writeVertex(vB);\n      writeVertex(vC);\n      if (binary === true) {\n        output.setUint16(offset, 0, true);\n        offset += 2;\n      } else {\n        output += \"\t\tendloop\\n\";\n        output += \"\tendfacet\\n\";\n      }\n    }\n    function writeNormal(vA2, vB2, vC2) {\n      cb.subVectors(vC2, vB2);\n      ab.subVectors(vA2, vB2);\n      cb.cross(ab).normalize();\n      normal.copy(cb).normalize();\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true);\n        offset += 4;\n        output.setFloat32(offset, normal.y, true);\n        offset += 4;\n        output.setFloat32(offset, normal.z, true);\n        offset += 4;\n      } else {\n        output += \"\tfacet normal \" + normal.x + \" \" + normal.y + \" \" + normal.z + \"\\n\";\n        output += \"\t\touter loop\\n\";\n      }\n    }\n    function writeVertex(vertex) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex.x, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.y, true);\n        offset += 4;\n        output.setFloat32(offset, vertex.z, true);\n        offset += 4;\n      } else {\n        output += \"\t\t\tvertex \" + vertex.x + \" \" + vertex.y + \" \" + vertex.z + \"\\n\";\n      }\n    }\n  }\n}\nexport { STLExporter };","map":{"version":3,"names":["STLExporter","parse","scene","options","arguments","length","undefined","Object","assign","binary","objects","triangles","traverse","object","isMesh","geometry","index","positionAttribute","getAttribute","count","push","object3d","output","offset","bufferLength","arrayBuffer","ArrayBuffer","DataView","setUint32","vA","Vector3","vB","vC","cb","ab","normal","i","il","j","a","getX","b","c","writeFace","fromBufferAttribute","isSkinnedMesh","applyBoneTransform","applyMatrix4","matrixWorld","writeNormal","writeVertex","setUint16","vA2","vB2","vC2","subVectors","cross","normalize","copy","setFloat32","x","y","z","vertex"],"sources":["/Users/omer/Local Repo/notomer.github.io/node_modules/src/exporters/STLExporter.js"],"sourcesContent":["import { Vector3 } from 'three'\n\n/**\n * Usage:\n *  const exporter = new STLExporter();\n *\n *  // second argument is a list of options\n *  const data = exporter.parse( mesh, { binary: true } );\n *\n */\n\nclass STLExporter {\n  parse(scene, options = {}) {\n    options = Object.assign(\n      {\n        binary: false,\n      },\n      options,\n    )\n\n    const binary = options.binary\n\n    //\n\n    const objects = []\n    let triangles = 0\n\n    scene.traverse(function (object) {\n      if (object.isMesh) {\n        const geometry = object.geometry\n\n        const index = geometry.index\n        const positionAttribute = geometry.getAttribute('position')\n\n        triangles += index !== null ? index.count / 3 : positionAttribute.count / 3\n\n        objects.push({\n          object3d: object,\n          geometry: geometry,\n        })\n      }\n    })\n\n    let output\n    let offset = 80 // skip header\n\n    if (binary === true) {\n      const bufferLength = triangles * 2 + triangles * 3 * 4 * 4 + 80 + 4\n      const arrayBuffer = new ArrayBuffer(bufferLength)\n      output = new DataView(arrayBuffer)\n      output.setUint32(offset, triangles, true)\n      offset += 4\n    } else {\n      output = ''\n      output += 'solid exported\\n'\n    }\n\n    const vA = new Vector3()\n    const vB = new Vector3()\n    const vC = new Vector3()\n    const cb = new Vector3()\n    const ab = new Vector3()\n    const normal = new Vector3()\n\n    for (let i = 0, il = objects.length; i < il; i++) {\n      const object = objects[i].object3d\n      const geometry = objects[i].geometry\n\n      const index = geometry.index\n      const positionAttribute = geometry.getAttribute('position')\n\n      if (index !== null) {\n        // indexed geometry\n\n        for (let j = 0; j < index.count; j += 3) {\n          const a = index.getX(j + 0)\n          const b = index.getX(j + 1)\n          const c = index.getX(j + 2)\n\n          writeFace(a, b, c, positionAttribute, object)\n        }\n      } else {\n        // non-indexed geometry\n\n        for (let j = 0; j < positionAttribute.count; j += 3) {\n          const a = j + 0\n          const b = j + 1\n          const c = j + 2\n\n          writeFace(a, b, c, positionAttribute, object)\n        }\n      }\n    }\n\n    if (binary === false) {\n      output += 'endsolid exported\\n'\n    }\n\n    return output\n\n    function writeFace(a, b, c, positionAttribute, object) {\n      vA.fromBufferAttribute(positionAttribute, a)\n      vB.fromBufferAttribute(positionAttribute, b)\n      vC.fromBufferAttribute(positionAttribute, c)\n\n      if (object.isSkinnedMesh === true) {\n        object.applyBoneTransform(a, vA)\n        object.applyBoneTransform(b, vB)\n        object.applyBoneTransform(c, vC)\n      }\n\n      vA.applyMatrix4(object.matrixWorld)\n      vB.applyMatrix4(object.matrixWorld)\n      vC.applyMatrix4(object.matrixWorld)\n\n      writeNormal(vA, vB, vC)\n\n      writeVertex(vA)\n      writeVertex(vB)\n      writeVertex(vC)\n\n      if (binary === true) {\n        output.setUint16(offset, 0, true)\n        offset += 2\n      } else {\n        output += '\\t\\tendloop\\n'\n        output += '\\tendfacet\\n'\n      }\n    }\n\n    function writeNormal(vA, vB, vC) {\n      cb.subVectors(vC, vB)\n      ab.subVectors(vA, vB)\n      cb.cross(ab).normalize()\n\n      normal.copy(cb).normalize()\n\n      if (binary === true) {\n        output.setFloat32(offset, normal.x, true)\n        offset += 4\n        output.setFloat32(offset, normal.y, true)\n        offset += 4\n        output.setFloat32(offset, normal.z, true)\n        offset += 4\n      } else {\n        output += '\\tfacet normal ' + normal.x + ' ' + normal.y + ' ' + normal.z + '\\n'\n        output += '\\t\\touter loop\\n'\n      }\n    }\n\n    function writeVertex(vertex) {\n      if (binary === true) {\n        output.setFloat32(offset, vertex.x, true)\n        offset += 4\n        output.setFloat32(offset, vertex.y, true)\n        offset += 4\n        output.setFloat32(offset, vertex.z, true)\n        offset += 4\n      } else {\n        output += '\\t\\t\\tvertex ' + vertex.x + ' ' + vertex.y + ' ' + vertex.z + '\\n'\n      }\n    }\n  }\n}\n\nexport { STLExporter }\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}