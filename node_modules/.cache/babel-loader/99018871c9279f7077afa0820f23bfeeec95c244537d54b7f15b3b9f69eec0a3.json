{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Instances, Instance } from './Instances.js';\nconst context = /*#__PURE__*/React.createContext(null);\nfunction useSpriteAnimator() {\n  return React.useContext(context);\n}\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef(({\n  startFrame,\n  endFrame,\n  fps,\n  frameName,\n  textureDataURL,\n  textureImageURL,\n  loop,\n  numberOfFrames,\n  autoPlay,\n  animationNames,\n  onStart,\n  onEnd,\n  onLoopEnd,\n  onFrame,\n  play,\n  pause,\n  flipX,\n  alphaTest,\n  children,\n  asSprite,\n  offset,\n  playBackwards,\n  resetOnEnd,\n  maxItems,\n  instanceItems,\n  ...props\n}, fref) => {\n  const ref = React.useRef();\n  const spriteData = React.useRef(null);\n  //const hasEnded = React.useRef(false)\n  const matRef = React.useRef();\n  const spriteRef = React.useRef();\n  const timerOffset = React.useRef(window.performance.now());\n  const textureData = React.useRef();\n  const currentFrame = React.useRef(startFrame || 0);\n  const currentFrameName = React.useRef(frameName || '');\n  const fpsInterval = 1000 / (fps || 30);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState([1, 1, 1]);\n  const flipOffset = flipX ? -1 : 1;\n  const [displayAsSprite, setDisplayAsSprite] = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  const pauseRef = React.useRef(pause);\n  const pos = React.useRef(offset);\n  const softEnd = React.useRef(false);\n  const frameBuffer = React.useRef([]);\n  //\n\n  function reset() {}\n  const state = React.useMemo(() => ({\n    current: pos.current,\n    offset: pos.current,\n    imageUrl: textureImageURL,\n    reset: reset,\n    hasEnded: false,\n    ref: fref\n  }), [textureImageURL]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    pos.current = offset;\n  }, [offset]);\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const textureLoader = new THREE.TextureLoader();\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const calculateAspectRatio = (width, height) => {\n    const aspectRatio = height / width;\n    if (spriteRef.current) {\n      spriteRef.current.scale.set(1, aspectRatio, 1);\n    }\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (textureDataURL && textureImageURL) {\n      loadJsonAndTextureAndExecuteCallback(textureDataURL, textureImageURL, parseSpriteData);\n    } else if (textureImageURL) {\n      // only load the texture, this is an image sprite only\n      const textureLoader = new THREE.TextureLoader();\n      new Promise(resolve => {\n        textureLoader.load(textureImageURL, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }, []);\n  React.useEffect(() => {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n\n  // support backwards play\n  React.useEffect(() => {\n    state.hasEnded = false;\n    if (spriteData.current && playBackwards === true) {\n      currentFrame.current = spriteData.current.frames.length - 1;\n    } else {\n      currentFrame.current = 0;\n    }\n  }, [playBackwards]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      state.hasEnded = false;\n      modifySpritePosition();\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstItem(spriteData.current.frames).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName]);\n\n  // parse sprite-data from JSON file (jsonHash or jsonArray)\n  const parseSpriteData = (json, _spriteTexture) => {\n    // sprite only case\n    if (json === null) {\n      if (numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        const frameWidth = width / numberOfFrames;\n        const frameHeight = height;\n        textureData.current = _spriteTexture;\n        totalFrames.current = numberOfFrames;\n        if (playBackwards) {\n          currentFrame.current = numberOfFrames - 1;\n        }\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (let i = 0; i < numberOfFrames; i++) {\n            spriteData.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n      }\n    } else {\n      spriteData.current = json;\n      spriteData.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      textureData.current = _spriteTexture;\n      if (playBackwards) {\n        currentFrame.current = totalFrames.current - 1;\n      }\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = _spriteTexture;\n      }\n    }\n\n    // buffer for instanced\n    if (instanceItems) {\n      for (var i = 0; i < instanceItems.length; i++) {\n        const keys = Object.keys(spriteData.current.frames);\n        const randomKey = keys[Math.floor(Math.random() * keys.length)];\n        frameBuffer.current.push({\n          key: i,\n          frames: spriteData.current.frames,\n          selectedFrame: randomKey,\n          offset: {\n            x: 0,\n            y: 0\n          }\n        });\n      }\n    }\n    _spriteTexture.premultiplyAlpha = false;\n    setSpriteTexture(_spriteTexture);\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteData.current;\n    const delimiters = animationNames;\n    if (delimiters) {\n      for (let i = 0; i < delimiters.length; i++) {\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else if (frameName) {\n      const spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      return spritesArr;\n    }\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = () => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    if (onStart) onStart({\n      currentFrameName: frameName,\n      currentFrame: currentFrame.current\n    });\n  };\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    //if (!frameName) return\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstItem(frames).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    var _offset = offset === undefined ? state.current : offset;\n\n    // conditionals to support backwards play\n    var endCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current > _endFrame;\n    var onStartCondition = playBackwards ? currentFrame.current === _endFrame : currentFrame.current === 0;\n    var manualProgressEndCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current >= _endFrame;\n    if (endCondition) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (playBackwards) {\n        currentFrame.current = _endFrame;\n      }\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        if (!_offset) {\n          console.log('will end');\n        }\n        state.hasEnded = resetOnEnd ? false : true;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n      if (!loop) return;\n    } else if (onStartCondition) {\n      onStart == null || onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n\n    // for manual update\n    if (_offset !== undefined && manualProgressEndCondition) {\n      if (softEnd.current === false) {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        softEnd.current = true;\n      }\n    } else {\n      // same for start?\n      softEnd.current = false;\n    }\n\n    // clock to limit fps\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    // get the manual update offset to find the next frame\n    var _offset = offset === undefined ? state.current : offset;\n    const targetFrame = currentFrame.current;\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = (metaInfo.w - 1) / frameW;\n    const framesV = (metaInfo.h - 1) / frameH;\n    if (!spriteFrames[targetFrame]) {\n      return;\n    }\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[targetFrame];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n\n    // if manual update is active\n    if (_offset !== undefined && _offset !== null) {\n      // Calculate the frame index, based on offset given from the provider\n      let frameIndex = Math.floor(_offset * spriteFrames.length);\n\n      // Ensure the frame index is within the valid range\n      frameIndex = Math.max(0, Math.min(frameIndex, spriteFrames.length - 1));\n      if (isNaN(frameIndex)) {\n        console.log('nan frame detected');\n        frameIndex = 0; //fallback\n      }\n      currentFrame.current = frameIndex;\n    } else {\n      // auto update\n      if (playBackwards) {\n        currentFrame.current -= 1;\n      } else {\n        currentFrame.current += 1;\n      }\n    }\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!state.hasEnded && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  const getFirstItem = param => {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      const keys = Object.keys(param);\n      return frameName ? param[frameName][0] : param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(Instances, {\n    limit: maxItems // Optional: max amount of items (for calculating buffer size)\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: [1, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }), (instanceItems !== null && instanceItems !== void 0 ? instanceItems : [0]).map((item, index) => {\n    const texture = spriteTexture.clone();\n    if (matRef.current && frameBuffer.current[index]) {\n      texture.offset.set(frameBuffer.current[index].offset.x, frameBuffer.current[index].offset.y); // Set the offset for this item\n    }\n    return /*#__PURE__*/React.createElement(Instance, {\n      key: index,\n      ref: spriteRef,\n      position: item,\n      scale: aspect\n    }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n      toneMapped: false,\n      side: THREE.DoubleSide,\n      map: texture,\n      transparent: true,\n      alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n    }));\n  }))), children));\n});\nexport { SpriteAnimator, useSpriteAnimator };","map":{"version":3,"names":["_extends","React","useFrame","THREE","Instances","Instance","context","createContext","useSpriteAnimator","useContext","SpriteAnimator","forwardRef","startFrame","endFrame","fps","frameName","textureDataURL","textureImageURL","loop","numberOfFrames","autoPlay","animationNames","onStart","onEnd","onLoopEnd","onFrame","play","pause","flipX","alphaTest","children","asSprite","offset","playBackwards","resetOnEnd","maxItems","instanceItems","props","fref","ref","useRef","spriteData","matRef","spriteRef","timerOffset","window","performance","now","textureData","currentFrame","currentFrameName","fpsInterval","spriteTexture","setSpriteTexture","useState","Texture","totalFrames","aspect","setAspect","flipOffset","displayAsSprite","setDisplayAsSprite","pauseRef","pos","softEnd","frameBuffer","reset","state","useMemo","current","imageUrl","hasEnded","useImperativeHandle","useLayoutEffect","loadJsonAndTextureAndExecuteCallback","jsonUrl","textureUrl","callback","textureLoader","TextureLoader","jsonPromise","fetch","then","response","json","texturePromise","Promise","resolve","load","all","calculateAspectRatio","width","height","aspectRatio","scale","set","useEffect","parseSpriteData","texture","frames","length","modifySpritePosition","w","h","getFirstItem","sourceSize","_aspect","_spriteTexture","image","frameWidth","frameHeight","meta","version","size","parseInt","toString","i","push","frame","x","y","rotated","trimmed","spriteSourceSize","Array","isArray","parseFrames","Object","keys","map","randomKey","Math","floor","random","key","selectedFrame","premultiplyAlpha","sprites","data","delimiters","innerKey","value","frameData","sourceWidth","sourceHeight","toLowerCase","indexOf","spritesArr","metaInfo","frameW","frameH","wrapS","wrapT","RepeatWrapping","center","repeat","framesV","frameOffsetY","runAnimation","diff","spriteFrames","_endFrame","_offset","undefined","endCondition","onStartCondition","manualProgressEndCondition","console","log","calculateFinalPosition","targetFrame","finalValX","finalValY","framesH","frameX","frameY","originalSizeX","originalSizeY","frameOffsetX","abs","frameIndex","max","min","isNaN","_state","_delta","_spriteData$current","_matRef$current","param","createElement","Provider","Suspense","fallback","toneMapped","transparent","limit","args","side","DoubleSide","item","index","clone","position"],"sources":["/Users/omer/Local Repo/notomer.github.io/node_modules/@react-three/drei/core/SpriteAnimator.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useFrame } from '@react-three/fiber';\nimport * as THREE from 'three';\nimport { Instances, Instance } from './Instances.js';\n\nconst context = /*#__PURE__*/React.createContext(null);\nfunction useSpriteAnimator() {\n  return React.useContext(context);\n}\nconst SpriteAnimator = /* @__PURE__ */React.forwardRef(({\n  startFrame,\n  endFrame,\n  fps,\n  frameName,\n  textureDataURL,\n  textureImageURL,\n  loop,\n  numberOfFrames,\n  autoPlay,\n  animationNames,\n  onStart,\n  onEnd,\n  onLoopEnd,\n  onFrame,\n  play,\n  pause,\n  flipX,\n  alphaTest,\n  children,\n  asSprite,\n  offset,\n  playBackwards,\n  resetOnEnd,\n  maxItems,\n  instanceItems,\n  ...props\n}, fref) => {\n  const ref = React.useRef();\n  const spriteData = React.useRef(null);\n  //const hasEnded = React.useRef(false)\n  const matRef = React.useRef();\n  const spriteRef = React.useRef();\n  const timerOffset = React.useRef(window.performance.now());\n  const textureData = React.useRef();\n  const currentFrame = React.useRef(startFrame || 0);\n  const currentFrameName = React.useRef(frameName || '');\n  const fpsInterval = 1000 / (fps || 30);\n  const [spriteTexture, setSpriteTexture] = React.useState(new THREE.Texture());\n  const totalFrames = React.useRef(0);\n  const [aspect, setAspect] = React.useState([1, 1, 1]);\n  const flipOffset = flipX ? -1 : 1;\n  const [displayAsSprite, setDisplayAsSprite] = React.useState(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  const pauseRef = React.useRef(pause);\n  const pos = React.useRef(offset);\n  const softEnd = React.useRef(false);\n  const frameBuffer = React.useRef([]);\n  //\n\n  function reset() {}\n  const state = React.useMemo(() => ({\n    current: pos.current,\n    offset: pos.current,\n    imageUrl: textureImageURL,\n    reset: reset,\n    hasEnded: false,\n    ref: fref\n  }), [textureImageURL]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  React.useLayoutEffect(() => {\n    pos.current = offset;\n  }, [offset]);\n  function loadJsonAndTextureAndExecuteCallback(jsonUrl, textureUrl, callback) {\n    const textureLoader = new THREE.TextureLoader();\n    const jsonPromise = fetch(jsonUrl).then(response => response.json());\n    const texturePromise = new Promise(resolve => {\n      textureLoader.load(textureUrl, resolve);\n    });\n    Promise.all([jsonPromise, texturePromise]).then(response => {\n      callback(response[0], response[1]);\n    });\n  }\n  const calculateAspectRatio = (width, height) => {\n    const aspectRatio = height / width;\n    if (spriteRef.current) {\n      spriteRef.current.scale.set(1, aspectRatio, 1);\n    }\n    return [1, aspectRatio, 1];\n  };\n\n  // initial loads\n  React.useEffect(() => {\n    if (textureDataURL && textureImageURL) {\n      loadJsonAndTextureAndExecuteCallback(textureDataURL, textureImageURL, parseSpriteData);\n    } else if (textureImageURL) {\n      // only load the texture, this is an image sprite only\n      const textureLoader = new THREE.TextureLoader();\n      new Promise(resolve => {\n        textureLoader.load(textureImageURL, resolve);\n      }).then(texture => {\n        parseSpriteData(null, texture);\n      });\n    }\n  }, []);\n  React.useEffect(() => {\n    setDisplayAsSprite(asSprite !== null && asSprite !== void 0 ? asSprite : true);\n  }, [asSprite]);\n\n  // support backwards play\n  React.useEffect(() => {\n    state.hasEnded = false;\n    if (spriteData.current && playBackwards === true) {\n      currentFrame.current = spriteData.current.frames.length - 1;\n    } else {\n      currentFrame.current = 0;\n    }\n  }, [playBackwards]);\n  React.useLayoutEffect(() => {\n    modifySpritePosition();\n  }, [spriteTexture, flipX]);\n  React.useEffect(() => {\n    if (autoPlay) {\n      pauseRef.current = false;\n    }\n  }, [autoPlay]);\n  React.useEffect(() => {\n    if (currentFrameName.current !== frameName && frameName) {\n      currentFrame.current = 0;\n      currentFrameName.current = frameName;\n      state.hasEnded = false;\n      modifySpritePosition();\n      if (spriteData.current) {\n        const {\n          w,\n          h\n        } = getFirstItem(spriteData.current.frames).sourceSize;\n        const _aspect = calculateAspectRatio(w, h);\n        setAspect(_aspect);\n      }\n    }\n  }, [frameName]);\n\n  // parse sprite-data from JSON file (jsonHash or jsonArray)\n  const parseSpriteData = (json, _spriteTexture) => {\n    // sprite only case\n    if (json === null) {\n      if (numberOfFrames) {\n        //get size from texture\n        const width = _spriteTexture.image.width;\n        const height = _spriteTexture.image.height;\n        const frameWidth = width / numberOfFrames;\n        const frameHeight = height;\n        textureData.current = _spriteTexture;\n        totalFrames.current = numberOfFrames;\n        if (playBackwards) {\n          currentFrame.current = numberOfFrames - 1;\n        }\n        spriteData.current = {\n          frames: [],\n          meta: {\n            version: '1.0',\n            size: {\n              w: width,\n              h: height\n            },\n            scale: '1'\n          }\n        };\n        if (parseInt(frameWidth.toString(), 10) === frameWidth) {\n          // if it fits\n          for (let i = 0; i < numberOfFrames; i++) {\n            spriteData.current.frames.push({\n              frame: {\n                x: i * frameWidth,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              rotated: false,\n              trimmed: false,\n              spriteSourceSize: {\n                x: 0,\n                y: 0,\n                w: frameWidth,\n                h: frameHeight\n              },\n              sourceSize: {\n                w: frameWidth,\n                h: height\n              }\n            });\n          }\n        }\n      }\n    } else {\n      spriteData.current = json;\n      spriteData.current.frames = Array.isArray(json.frames) ? json.frames : parseFrames();\n      totalFrames.current = Array.isArray(json.frames) ? json.frames.length : Object.keys(json.frames).length;\n      textureData.current = _spriteTexture;\n      if (playBackwards) {\n        currentFrame.current = totalFrames.current - 1;\n      }\n      const {\n        w,\n        h\n      } = getFirstItem(json.frames).sourceSize;\n      const aspect = calculateAspectRatio(w, h);\n      setAspect(aspect);\n      if (matRef.current) {\n        matRef.current.map = _spriteTexture;\n      }\n    }\n\n    // buffer for instanced\n    if (instanceItems) {\n      for (var i = 0; i < instanceItems.length; i++) {\n        const keys = Object.keys(spriteData.current.frames);\n        const randomKey = keys[Math.floor(Math.random() * keys.length)];\n        frameBuffer.current.push({\n          key: i,\n          frames: spriteData.current.frames,\n          selectedFrame: randomKey,\n          offset: {\n            x: 0,\n            y: 0\n          }\n        });\n      }\n    }\n    _spriteTexture.premultiplyAlpha = false;\n    setSpriteTexture(_spriteTexture);\n  };\n\n  // for frame based JSON Hash sprite data\n  const parseFrames = () => {\n    const sprites = {};\n    const data = spriteData.current;\n    const delimiters = animationNames;\n    if (delimiters) {\n      for (let i = 0; i < delimiters.length; i++) {\n        sprites[delimiters[i]] = [];\n        for (const innerKey in data['frames']) {\n          const value = data['frames'][innerKey];\n          const frameData = value['frame'];\n          const x = frameData['x'];\n          const y = frameData['y'];\n          const width = frameData['w'];\n          const height = frameData['h'];\n          const sourceWidth = value['sourceSize']['w'];\n          const sourceHeight = value['sourceSize']['h'];\n          if (innerKey.toLowerCase().indexOf(delimiters[i].toLowerCase()) !== -1) {\n            sprites[delimiters[i]].push({\n              x: x,\n              y: y,\n              w: width,\n              h: height,\n              frame: frameData,\n              sourceSize: {\n                w: sourceWidth,\n                h: sourceHeight\n              }\n            });\n          }\n        }\n      }\n      return sprites;\n    } else if (frameName) {\n      const spritesArr = [];\n      for (const key in data.frames) {\n        spritesArr.push(data.frames[key]);\n      }\n      return spritesArr;\n    }\n  };\n\n  // modify the sprite material after json is parsed and state updated\n  const modifySpritePosition = () => {\n    if (!spriteData.current) return;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = Array.isArray(frames) ? frames[0].sourceSize : frameName ? frames[frameName] ? frames[frameName][0].sourceSize : {\n      w: 0,\n      h: 0\n    } : {\n      w: 0,\n      h: 0\n    };\n    matRef.current.map.wrapS = matRef.current.map.wrapT = THREE.RepeatWrapping;\n    matRef.current.map.center.set(0, 0);\n    matRef.current.map.repeat.set(1 * flipOffset / (metaInfo.w / frameW), 1 / (metaInfo.h / frameH));\n\n    //const framesH = (metaInfo.w - 1) / frameW\n    const framesV = (metaInfo.h - 1) / frameH;\n    const frameOffsetY = 1 / framesV;\n    matRef.current.map.offset.x = 0.0; //-matRef.current.map.repeat.x\n    matRef.current.map.offset.y = 1 - frameOffsetY;\n    if (onStart) onStart({\n      currentFrameName: frameName,\n      currentFrame: currentFrame.current\n    });\n  };\n\n  // run the animation on each frame\n  const runAnimation = () => {\n    //if (!frameName) return\n    const now = window.performance.now();\n    const diff = now - timerOffset.current;\n    const {\n      meta: {\n        size: metaInfo\n      },\n      frames\n    } = spriteData.current;\n    const {\n      w: frameW,\n      h: frameH\n    } = getFirstItem(frames).sourceSize;\n    const spriteFrames = Array.isArray(frames) ? frames : frameName ? frames[frameName] : [];\n    const _endFrame = endFrame || spriteFrames.length - 1;\n    var _offset = offset === undefined ? state.current : offset;\n\n    // conditionals to support backwards play\n    var endCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current > _endFrame;\n    var onStartCondition = playBackwards ? currentFrame.current === _endFrame : currentFrame.current === 0;\n    var manualProgressEndCondition = playBackwards ? currentFrame.current < 0 : currentFrame.current >= _endFrame;\n    if (endCondition) {\n      currentFrame.current = loop ? startFrame !== null && startFrame !== void 0 ? startFrame : 0 : 0;\n      if (playBackwards) {\n        currentFrame.current = _endFrame;\n      }\n      if (loop) {\n        onLoopEnd == null || onLoopEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n      } else {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        if (!_offset) {\n          console.log('will end');\n        }\n        state.hasEnded = resetOnEnd ? false : true;\n        if (resetOnEnd) {\n          pauseRef.current = true;\n          //calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames)\n        }\n      }\n\n      if (!loop) return;\n    } else if (onStartCondition) {\n      onStart == null || onStart({\n        currentFrameName: frameName,\n        currentFrame: currentFrame.current\n      });\n    }\n\n    // for manual update\n    if (_offset !== undefined && manualProgressEndCondition) {\n      if (softEnd.current === false) {\n        onEnd == null || onEnd({\n          currentFrameName: frameName,\n          currentFrame: currentFrame.current\n        });\n        softEnd.current = true;\n      }\n    } else {\n      // same for start?\n      softEnd.current = false;\n    }\n\n    // clock to limit fps\n    if (diff <= fpsInterval) return;\n    timerOffset.current = now - diff % fpsInterval;\n    calculateFinalPosition(frameW, frameH, metaInfo, spriteFrames);\n  };\n  const calculateFinalPosition = (frameW, frameH, metaInfo, spriteFrames) => {\n    // get the manual update offset to find the next frame\n    var _offset = offset === undefined ? state.current : offset;\n    const targetFrame = currentFrame.current;\n    let finalValX = 0;\n    let finalValY = 0;\n    calculateAspectRatio(frameW, frameH);\n    const framesH = (metaInfo.w - 1) / frameW;\n    const framesV = (metaInfo.h - 1) / frameH;\n    if (!spriteFrames[targetFrame]) {\n      return;\n    }\n    const {\n      frame: {\n        x: frameX,\n        y: frameY\n      },\n      sourceSize: {\n        w: originalSizeX,\n        h: originalSizeY\n      }\n    } = spriteFrames[targetFrame];\n    const frameOffsetX = 1 / framesH;\n    const frameOffsetY = 1 / framesV;\n    finalValX = flipOffset > 0 ? frameOffsetX * (frameX / originalSizeX) : frameOffsetX * (frameX / originalSizeX) - matRef.current.map.repeat.x;\n    finalValY = Math.abs(1 - frameOffsetY) - frameOffsetY * (frameY / originalSizeY);\n    matRef.current.map.offset.x = finalValX;\n    matRef.current.map.offset.y = finalValY;\n\n    // if manual update is active\n    if (_offset !== undefined && _offset !== null) {\n      // Calculate the frame index, based on offset given from the provider\n      let frameIndex = Math.floor(_offset * spriteFrames.length);\n\n      // Ensure the frame index is within the valid range\n      frameIndex = Math.max(0, Math.min(frameIndex, spriteFrames.length - 1));\n      if (isNaN(frameIndex)) {\n        console.log('nan frame detected');\n        frameIndex = 0; //fallback\n      }\n\n      currentFrame.current = frameIndex;\n    } else {\n      // auto update\n      if (playBackwards) {\n        currentFrame.current -= 1;\n      } else {\n        currentFrame.current += 1;\n      }\n    }\n  };\n\n  // *** Warning! It runs on every frame! ***\n  useFrame((_state, _delta) => {\n    var _spriteData$current, _matRef$current;\n    if (!((_spriteData$current = spriteData.current) != null && _spriteData$current.frames) || !((_matRef$current = matRef.current) != null && _matRef$current.map)) {\n      return;\n    }\n    if (pauseRef.current) {\n      return;\n    }\n    if (!state.hasEnded && (autoPlay || play)) {\n      runAnimation();\n      onFrame && onFrame({\n        currentFrameName: currentFrameName.current,\n        currentFrame: currentFrame.current\n      });\n    }\n  });\n\n  // utils\n  const getFirstItem = param => {\n    if (Array.isArray(param)) {\n      return param[0];\n    } else if (typeof param === 'object' && param !== null) {\n      const keys = Object.keys(param);\n      return frameName ? param[frameName][0] : param[keys[0]][0];\n    } else {\n      return {\n        w: 0,\n        h: 0\n      };\n    }\n  };\n  return /*#__PURE__*/React.createElement(\"group\", _extends({}, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(context.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(React.Suspense, {\n    fallback: null\n  }, displayAsSprite && /*#__PURE__*/React.createElement(\"sprite\", {\n    ref: spriteRef,\n    scale: aspect\n  }, /*#__PURE__*/React.createElement(\"spriteMaterial\", {\n    toneMapped: false,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  })), !displayAsSprite && /*#__PURE__*/React.createElement(Instances, {\n    limit: maxItems // Optional: max amount of items (for calculating buffer size)\n  }, /*#__PURE__*/React.createElement(\"planeGeometry\", {\n    args: [1, 1]\n  }), /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n    toneMapped: false,\n    side: THREE.DoubleSide,\n    ref: matRef,\n    map: spriteTexture,\n    transparent: true,\n    alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n  }), (instanceItems !== null && instanceItems !== void 0 ? instanceItems : [0]).map((item, index) => {\n    const texture = spriteTexture.clone();\n    if (matRef.current && frameBuffer.current[index]) {\n      texture.offset.set(frameBuffer.current[index].offset.x, frameBuffer.current[index].offset.y); // Set the offset for this item\n    }\n\n    return /*#__PURE__*/React.createElement(Instance, {\n      key: index,\n      ref: spriteRef,\n      position: item,\n      scale: aspect\n    }, /*#__PURE__*/React.createElement(\"meshBasicMaterial\", {\n      toneMapped: false,\n      side: THREE.DoubleSide,\n      map: texture,\n      transparent: true,\n      alphaTest: alphaTest !== null && alphaTest !== void 0 ? alphaTest : 0.0\n    }));\n  }))), children));\n});\n\nexport { SpriteAnimator, useSpriteAnimator };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}