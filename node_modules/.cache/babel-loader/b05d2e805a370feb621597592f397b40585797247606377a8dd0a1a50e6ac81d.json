{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.RenderDelegateInterface = void 0;\nvar THREE = require(\"three\");\nvar TextureRegistry = /** @class */function () {\n  function TextureRegistry(basename) {\n    this.basename = basename;\n    this.textures = [];\n    this.loader = new THREE.TextureLoader();\n  }\n  TextureRegistry.prototype.getTexture = function (filename) {\n    var _this = this;\n    if (this.textures[filename]) {\n      return this.textures[filename];\n    }\n    var textureResolve, textureReject;\n    this.textures[filename] = new Promise(function (resolve, reject) {\n      textureResolve = resolve;\n      textureReject = reject;\n    });\n    var resourcePath = filename;\n    if (filename[0] !== \"/\") {\n      resourcePath = this.basename + \"[\" + filename + \"]\";\n    }\n    var filetype = undefined;\n    if (filename.indexOf(\".png\") >= filename.length - 5) {\n      filetype = \"image/png\";\n    } else if (filename.indexOf(\".jpg\") >= filename.length - 5) {\n      filetype = \"image/jpeg\";\n    } else if (filename.indexOf(\".jpeg\") >= filename.length - 5) {\n      filetype = \"image/jpeg\";\n    } else {\n      throw new Error(\"Unknown filetype\");\n    }\n    window.driver.getFile(resourcePath, function (loadedFile) {\n      if (!loadedFile) {\n        textureReject(new Error(\"Unknown file: \" + resourcePath));\n        return;\n      }\n      var blob = new Blob([loadedFile.slice(0)], {\n        type: filetype\n      });\n      var blobUrl = URL.createObjectURL(blob);\n      // Load the texture\n      _this.loader.load(\n      // resource URL\n      blobUrl,\n      // onLoad callback\n      function (texture) {\n        textureResolve(texture);\n      },\n      // onProgress callback currently not used\n      undefined,\n      // onError callback\n      function (err) {\n        textureReject(err);\n      });\n    });\n    return this.textures[filename];\n  };\n  return TextureRegistry;\n}();\nvar HydraMesh = /** @class */function () {\n  function HydraMesh(id, hydraInterface) {\n    this._geometry = new THREE.BufferGeometry();\n    this._id = id;\n    this._interface = hydraInterface;\n    this._points = undefined;\n    this._normals = undefined;\n    this._colors = undefined;\n    this._uvs = undefined;\n    this._indices = undefined;\n    var material = new THREE.MeshPhysicalMaterial({\n      side: THREE.DoubleSide,\n      color: new THREE.Color(0x00ff00) // a green color to indicate a missing material\n    });\n\n    this._mesh = new THREE.Mesh(this._geometry, material);\n    this._mesh.castShadow = true;\n    this._mesh.receiveShadow = true;\n    window.usdRoot.add(this._mesh); // FIXME\n  }\n\n  HydraMesh.prototype.updateOrder = function (attribute, attributeName, dimension) {\n    if (dimension === void 0) {\n      dimension = 3;\n    }\n    if (attribute && this._indices) {\n      var values = [];\n      for (var i = 0; i < this._indices.length; i++) {\n        var index = this._indices[i];\n        for (var j = 0; j < dimension; ++j) {\n          values.push(attribute[dimension * index + j]);\n        }\n      }\n      this._geometry.setAttribute(attributeName, new THREE.Float32BufferAttribute(values, dimension));\n    }\n  };\n  HydraMesh.prototype.updateIndices = function (indices) {\n    this._indices = [];\n    for (var i = 0; i < indices.length; i++) {\n      this._indices.push(indices[i]);\n    }\n    //this._geometry.setIndex( indicesArray );\n    this.updateOrder(this._points, \"position\");\n    this.updateOrder(this._normals, \"normal\");\n    if (this._colors) {\n      this.updateOrder(this._colors, \"color\");\n    }\n    if (this._uvs) {\n      this.updateOrder(this._uvs, \"uv\", 2);\n      this._geometry.attributes.uv2 = this._geometry.attributes.uv;\n    }\n  };\n  HydraMesh.prototype.setTransform = function (matrix) {\n    var _a;\n    (_a = this._mesh.matrix).set.apply(_a, matrix);\n    this._mesh.matrix.transpose();\n    this._mesh.matrixAutoUpdate = false;\n  };\n  HydraMesh.prototype.updateNormals = function (normals) {\n    this._normals = normals.slice(0);\n    this.updateOrder(this._normals, \"normal\");\n  };\n  // This is always called before prims are updated\n  HydraMesh.prototype.setMaterial = function (materialId) {\n    //console.log(\"Material: \" + materialId);\n    if (this._interface.materials[materialId]) {\n      this._mesh.material = this._interface.materials[materialId]._material;\n    }\n  };\n  HydraMesh.prototype.setDisplayColor = function (data, interpolation) {\n    var wasDefaultMaterial = false;\n    if (this._mesh.material === defaultMaterial) {\n      this._mesh.material = this._mesh.material.clone();\n      wasDefaultMaterial = true;\n    }\n    this._colors = null;\n    if (interpolation === \"constant\") {\n      this._mesh.material.color = new THREE.Color().fromArray(data);\n    } else if (interpolation === \"vertex\") {\n      // Per-vertex buffer attribute\n      this._mesh.material.vertexColors = true;\n      if (wasDefaultMaterial) {\n        // Reset the pink debugging color\n        this._mesh.material.color = new THREE.Color(0xffffff);\n      }\n      this._colors = data.slice(0);\n      this.updateOrder(this._colors, \"color\");\n    } else {\n      //console.warn(\n      // `Unsupported displayColor interpolation type '${interpolation}'.`\n      //);\n    }\n  };\n  HydraMesh.prototype.setUV = function (data, dimension, interpolation) {\n    // TODO: Support multiple UVs. For now, we simply set uv = uv2, which is required when a material has an aoMap.\n    this._uvs = null;\n    if (interpolation === \"facevarying\") {\n      // The UV buffer has already been prepared on the C++ side, so we just set it\n      this._geometry.setAttribute(\"uv\", new THREE.Float32BufferAttribute(data, dimension));\n    } else if (interpolation === \"vertex\") {\n      // We have per-vertex UVs, so we need to sort them accordingly\n      this._uvs = data.slice(0);\n      this.updateOrder(this._uvs, \"uv\", 2);\n    }\n    this._geometry.attributes.uv2 = this._geometry.attributes.uv;\n  };\n  HydraMesh.prototype.updatePrimvar = function (name, data, dimension, interpolation) {\n    if (name === \"points\" || name === \"normals\") {\n      // Points and normals are set separately\n      return;\n    }\n    //console.log(\"Setting PrimVar: \" + name);\n    // TODO: Support multiple UVs. For now, we simply set uv = uv2, which is required when a material has an aoMap.\n    if (name.startsWith(\"st\")) {\n      name = \"uv\";\n    }\n    switch (name) {\n      case \"displayColor\":\n        this.setDisplayColor(data, interpolation);\n        break;\n      case \"uv\":\n        this.setUV(data, dimension, interpolation);\n        break;\n      default:\n      //console.warn(\"Unsupported primvar\", name);\n    }\n  };\n\n  HydraMesh.prototype.updatePoints = function (points) {\n    this._points = points.slice(0);\n    this.updateOrder(this._points, \"position\");\n  };\n  HydraMesh.prototype.commit = function () {\n    // Nothing to do here. All Three.js resources are already updated during the sync phase.\n  };\n  return HydraMesh;\n}();\nvar defaultMaterial;\nvar HydraMaterial = /** @class */function () {\n  function HydraMaterial(id, hydraInterface) {\n    this._id = id;\n    this._nodes = {};\n    this._interface = hydraInterface;\n    if (!defaultMaterial) {\n      defaultMaterial = new THREE.MeshPhysicalMaterial({\n        side: THREE.DoubleSide,\n        color: new THREE.Color(0xff2997),\n        envMap: window.envMap\n      });\n    }\n    this._material = defaultMaterial;\n  }\n  HydraMaterial.prototype.updateNode = function (networkId, path, parameters) {\n    //console.log(\"Updating Material Node: \" + networkId + \" \" + path);\n    this._nodes[path] = parameters;\n  };\n  HydraMaterial.prototype.assignTexture = function (mainMaterial, parameterName) {\n    var _this = this;\n    var materialParameterMapName = HydraMaterial.usdPreviewToMeshPhysicalTextureMap[parameterName];\n    if (materialParameterMapName === undefined) {\n      //console.warn(\n      //  `Unsupported material texture parameter '${parameterName}'.`\n      //);\n      return;\n    }\n    if (mainMaterial[parameterName] && mainMaterial[parameterName].nodeIn) {\n      var textureFileName_1 = mainMaterial[parameterName].nodeIn.file;\n      var channel_1 = mainMaterial[parameterName].inputName;\n      // For debugging\n      var matName = Object.keys(this._nodes).find(function (key) {\n        return _this._nodes[key] === mainMaterial;\n      });\n      //console.log(\n      //  `Setting texture '${materialParameterMapName}' (${textureFileName}) of material '${matName}'...`\n      //);\n      this._interface.registry.getTexture(textureFileName_1).then(function (texture) {\n        var _a, _b;\n        if (materialParameterMapName === \"alphaMap\") {\n          // If this is an opacity map, check if it's using the alpha channel of the diffuse map.\n          // If so, simply change the format of that diffuse map to RGBA and make the material transparent.\n          // If not, we need to copy the alpha channel into a new texture's green channel, because that's what Three.js\n          // expects for alpha maps (not supported at the moment).\n          // NOTE that this only works if diffuse maps are always set before opacity maps, so the order of\n          // 'assingTexture' calls for a material matters.\n          if (textureFileName_1 === ((_b = (_a = mainMaterial.diffuseColor) === null || _a === void 0 ? void 0 : _a.nodeIn) === null || _b === void 0 ? void 0 : _b.file) && channel_1 === \"a\") {\n            _this._material.map.format = THREE.RGBAFormat;\n          } else {\n            // TODO: Extract the alpha channel into a new RGB texture.\n          }\n          _this._material.transparent = true;\n          _this._material.needsUpdate = true;\n          return;\n        } else if (materialParameterMapName === \"metalnessMap\") {\n          _this._material.metalness = 1.0;\n        } else if (materialParameterMapName === \"emissiveMap\") {\n          _this._material.emissive = new THREE.Color(0xffffff);\n        } else if (!HydraMaterial.channelMap[channel_1]) {\n          //console.warn(`Unsupported texture channel '${channel}'!`);\n          return;\n        }\n        // Clone texture and set the correct format.\n        var clonedTexture = texture.clone();\n        clonedTexture.format = HydraMaterial.channelMap[channel_1];\n        clonedTexture.needsUpdate = true;\n        clonedTexture.wrapS = THREE.RepeatWrapping;\n        clonedTexture.wrapT = THREE.RepeatWrapping;\n        _this._material[materialParameterMapName] = clonedTexture;\n        _this._material.needsUpdate = true;\n      });\n    } else {\n      this._material[materialParameterMapName] = undefined;\n    }\n  };\n  HydraMaterial.prototype.assignProperty = function (mainMaterial, parameterName) {\n    var materialParameterName = HydraMaterial.usdPreviewToMeshPhysicalMap[parameterName];\n    if (materialParameterName === undefined) {\n      //console.warn(`Unsupported material parameter '${parameterName}'.`);\n      return;\n    }\n    if (mainMaterial[parameterName] !== undefined && !mainMaterial[parameterName].nodeIn) {\n      //console.log(\n      //  `Assigning property ${parameterName}: ${mainMaterial[parameterName]}`\n      //);\n      if (Array.isArray(mainMaterial[parameterName])) {\n        this._material[materialParameterName] = new THREE.Color().fromArray(mainMaterial[parameterName]);\n      } else {\n        this._material[materialParameterName] = mainMaterial[parameterName];\n        if (materialParameterName === \"opacity\" && mainMaterial[parameterName] < 1.0) {\n          this._material.transparent = true;\n        }\n      }\n    }\n  };\n  HydraMaterial.prototype.updateFinished = function (type, relationships) {\n    for (var _i = 0, relationships_1 = relationships; _i < relationships_1.length; _i++) {\n      var relationship = relationships_1[_i];\n      relationship.nodeIn = this._nodes[relationship.inputId];\n      relationship.nodeOut = this._nodes[relationship.outputId];\n      relationship.nodeIn[relationship.inputName] = relationship;\n      relationship.nodeOut[relationship.outputName] = relationship;\n    }\n    //console.log(\"Finalizing Material: \" + this._id);\n    // find the main material node\n    var mainMaterialNode = undefined;\n    for (var _a = 0, _b = Object.values(this._nodes); _a < _b.length; _a++) {\n      var node = _b[_a];\n      if (node.diffuseColor) {\n        mainMaterialNode = node;\n        break;\n      }\n    }\n    if (!mainMaterialNode) {\n      this._material = defaultMaterial;\n      return;\n    }\n    // TODO: Ideally, we don't recreate the material on every update.\n    // Creating a new one requires to also update any meshes that reference it. So we're relying on the C++ side to\n    // call this before also calling `setMaterial` on the affected meshes.\n    //console.log(\"Creating Material: \" + this._id);\n    this._material = new THREE.MeshPhysicalMaterial({});\n    // Assign textures\n    for (var key in HydraMaterial.usdPreviewToMeshPhysicalTextureMap) {\n      this.assignTexture(mainMaterialNode, key);\n    }\n    // Assign material properties\n    for (var key in HydraMaterial.usdPreviewToMeshPhysicalMap) {\n      this.assignProperty(mainMaterialNode, key);\n    }\n    if (window.envMap) {\n      this._material.envMap = window.envMap;\n    }\n    //console.log(this._material);\n  };\n  // Maps USD preview material texture names to Three.js MeshPhysicalMaterial names\n  HydraMaterial.usdPreviewToMeshPhysicalTextureMap = {\n    diffuseColor: \"map\",\n    clearcoat: \"clearcoatMap\",\n    clearcoatRoughness: \"clearcoatRoughnessMap\",\n    emissiveColor: \"emissiveMap\",\n    occlusion: \"aoMap\",\n    roughness: \"roughnessMap\",\n    metallic: \"metalnessMap\",\n    normal: \"normalMap\",\n    opacity: \"alphaMap\"\n  };\n  HydraMaterial.channelMap = {\n    // Three.js expects many 8bit values such as roughness or metallness in a specific RGB texture channel.\n    // We could write code to combine multiple 8bit texture files into different channels of one RGB texture where it\n    // makes sense, but that would complicate this loader a lot. Most Three.js loaders don't seem to do it either.\n    // Instead, we simply provide the 8bit image as an RGB texture, even though this might be less efficient.\n    r: THREE.RGBAFormat,\n    rgb: THREE.RGBAFormat,\n    rgba: THREE.RGBAFormat\n  };\n  // Maps USD preview material property names to Three.js MeshPhysicalMaterial names\n  HydraMaterial.usdPreviewToMeshPhysicalMap = {\n    clearcoat: \"clearcoat\",\n    clearcoatRoughness: \"clearcoatRoughness\",\n    diffuseColor: \"color\",\n    emissiveColor: \"emissive\",\n    ior: \"ior\",\n    metallic: \"metalness\",\n    opacity: \"opacity\",\n    roughness: \"roughness\"\n  };\n  return HydraMaterial;\n}();\nvar RenderDelegateInterface = /** @class */function () {\n  function RenderDelegateInterface(filename, usdRoot) {\n    this.registry = new TextureRegistry(filename);\n    this.materials = {};\n    this.meshes = {};\n    window.usdRoot = usdRoot;\n  }\n  RenderDelegateInterface.prototype.createRPrim = function (typeId, id, instancerId) {\n    //console.log(\"Creating RPrim: \" + typeId + \" \" + id);\n    var mesh = new HydraMesh(id, this);\n    this.meshes[id] = mesh;\n    return mesh;\n  };\n  RenderDelegateInterface.prototype.createBPrim = function (typeId, id) {\n    //console.log(\"Creating BPrim: \" + typeId + \" \" + id);\n    /*let mesh = new HydraMesh(id, this);\r\n    this.meshes[id] = mesh;\r\n    return mesh;*/\n  };\n  RenderDelegateInterface.prototype.createSPrim = function (typeId, id) {\n    //console.log(\"Creating SPrim: \" + typeId + \" \" + id);\n    if (typeId === \"material\") {\n      var material = new HydraMaterial(id, this);\n      this.materials[id] = material;\n      return material;\n    } else {\n      return undefined;\n    }\n  };\n  RenderDelegateInterface.prototype.setDriver = function (driver) {\n    window.driver = driver;\n  };\n  RenderDelegateInterface.prototype.CommitResources = function () {\n    for (var id in this.meshes) {\n      var hydraMesh = this.meshes[id];\n      hydraMesh.commit();\n    }\n  };\n  return RenderDelegateInterface;\n}();\nexports.RenderDelegateInterface = RenderDelegateInterface;","map":{"version":3,"names":["Object","defineProperty","exports","value","RenderDelegateInterface","THREE","require","TextureRegistry","basename","textures","loader","TextureLoader","prototype","getTexture","filename","_this","textureResolve","textureReject","Promise","resolve","reject","resourcePath","filetype","undefined","indexOf","length","Error","window","driver","getFile","loadedFile","blob","Blob","slice","type","blobUrl","URL","createObjectURL","load","texture","err","HydraMesh","id","hydraInterface","_geometry","BufferGeometry","_id","_interface","_points","_normals","_colors","_uvs","_indices","material","MeshPhysicalMaterial","side","DoubleSide","color","Color","_mesh","Mesh","castShadow","receiveShadow","usdRoot","add","updateOrder","attribute","attributeName","dimension","values","i","index","j","push","setAttribute","Float32BufferAttribute","updateIndices","indices","attributes","uv2","uv","setTransform","matrix","_a","set","apply","transpose","matrixAutoUpdate","updateNormals","normals","setMaterial","materialId","materials","_material","setDisplayColor","data","interpolation","wasDefaultMaterial","defaultMaterial","clone","fromArray","vertexColors","setUV","updatePrimvar","name","startsWith","updatePoints","points","commit","HydraMaterial","_nodes","envMap","updateNode","networkId","path","parameters","assignTexture","mainMaterial","parameterName","materialParameterMapName","usdPreviewToMeshPhysicalTextureMap","nodeIn","textureFileName_1","file","channel_1","inputName","matName","keys","find","key","registry","then","_b","diffuseColor","map","format","RGBAFormat","transparent","needsUpdate","metalness","emissive","channelMap","clonedTexture","wrapS","RepeatWrapping","wrapT","assignProperty","materialParameterName","usdPreviewToMeshPhysicalMap","Array","isArray","updateFinished","relationships","_i","relationships_1","relationship","inputId","nodeOut","outputId","outputName","mainMaterialNode","node","clearcoat","clearcoatRoughness","emissiveColor","occlusion","roughness","metallic","normal","opacity","r","rgb","rgba","ior","meshes","createRPrim","typeId","instancerId","mesh","createBPrim","createSPrim","setDriver","CommitResources","hydraMesh"],"sources":["/Users/omer/Local Repo/notomer.github.io/node_modules/three-usdz-loader/lib/ThreeJsRenderDelegate.js"],"sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RenderDelegateInterface = void 0;\r\nvar THREE = require(\"three\");\r\nvar TextureRegistry = /** @class */ (function () {\r\n    function TextureRegistry(basename) {\r\n        this.basename = basename;\r\n        this.textures = [];\r\n        this.loader = new THREE.TextureLoader();\r\n    }\r\n    TextureRegistry.prototype.getTexture = function (filename) {\r\n        var _this = this;\r\n        if (this.textures[filename]) {\r\n            return this.textures[filename];\r\n        }\r\n        var textureResolve, textureReject;\r\n        this.textures[filename] = new Promise(function (resolve, reject) {\r\n            textureResolve = resolve;\r\n            textureReject = reject;\r\n        });\r\n        var resourcePath = filename;\r\n        if (filename[0] !== \"/\") {\r\n            resourcePath = this.basename + \"[\" + filename + \"]\";\r\n        }\r\n        var filetype = undefined;\r\n        if (filename.indexOf(\".png\") >= filename.length - 5) {\r\n            filetype = \"image/png\";\r\n        }\r\n        else if (filename.indexOf(\".jpg\") >= filename.length - 5) {\r\n            filetype = \"image/jpeg\";\r\n        }\r\n        else if (filename.indexOf(\".jpeg\") >= filename.length - 5) {\r\n            filetype = \"image/jpeg\";\r\n        }\r\n        else {\r\n            throw new Error(\"Unknown filetype\");\r\n        }\r\n        window.driver.getFile(resourcePath, function (loadedFile) {\r\n            if (!loadedFile) {\r\n                textureReject(new Error(\"Unknown file: \" + resourcePath));\r\n                return;\r\n            }\r\n            var blob = new Blob([loadedFile.slice(0)], { type: filetype });\r\n            var blobUrl = URL.createObjectURL(blob);\r\n            // Load the texture\r\n            _this.loader.load(\r\n            // resource URL\r\n            blobUrl, \r\n            // onLoad callback\r\n            function (texture) {\r\n                textureResolve(texture);\r\n            }, \r\n            // onProgress callback currently not used\r\n            undefined, \r\n            // onError callback\r\n            function (err) {\r\n                textureReject(err);\r\n            });\r\n        });\r\n        return this.textures[filename];\r\n    };\r\n    return TextureRegistry;\r\n}());\r\nvar HydraMesh = /** @class */ (function () {\r\n    function HydraMesh(id, hydraInterface) {\r\n        this._geometry = new THREE.BufferGeometry();\r\n        this._id = id;\r\n        this._interface = hydraInterface;\r\n        this._points = undefined;\r\n        this._normals = undefined;\r\n        this._colors = undefined;\r\n        this._uvs = undefined;\r\n        this._indices = undefined;\r\n        var material = new THREE.MeshPhysicalMaterial({\r\n            side: THREE.DoubleSide,\r\n            color: new THREE.Color(0x00ff00), // a green color to indicate a missing material\r\n        });\r\n        this._mesh = new THREE.Mesh(this._geometry, material);\r\n        this._mesh.castShadow = true;\r\n        this._mesh.receiveShadow = true;\r\n        window.usdRoot.add(this._mesh); // FIXME\r\n    }\r\n    HydraMesh.prototype.updateOrder = function (attribute, attributeName, dimension) {\r\n        if (dimension === void 0) { dimension = 3; }\r\n        if (attribute && this._indices) {\r\n            var values = [];\r\n            for (var i = 0; i < this._indices.length; i++) {\r\n                var index = this._indices[i];\r\n                for (var j = 0; j < dimension; ++j) {\r\n                    values.push(attribute[dimension * index + j]);\r\n                }\r\n            }\r\n            this._geometry.setAttribute(attributeName, new THREE.Float32BufferAttribute(values, dimension));\r\n        }\r\n    };\r\n    HydraMesh.prototype.updateIndices = function (indices) {\r\n        this._indices = [];\r\n        for (var i = 0; i < indices.length; i++) {\r\n            this._indices.push(indices[i]);\r\n        }\r\n        //this._geometry.setIndex( indicesArray );\r\n        this.updateOrder(this._points, \"position\");\r\n        this.updateOrder(this._normals, \"normal\");\r\n        if (this._colors) {\r\n            this.updateOrder(this._colors, \"color\");\r\n        }\r\n        if (this._uvs) {\r\n            this.updateOrder(this._uvs, \"uv\", 2);\r\n            this._geometry.attributes.uv2 = this._geometry.attributes.uv;\r\n        }\r\n    };\r\n    HydraMesh.prototype.setTransform = function (matrix) {\r\n        var _a;\r\n        (_a = this._mesh.matrix).set.apply(_a, matrix);\r\n        this._mesh.matrix.transpose();\r\n        this._mesh.matrixAutoUpdate = false;\r\n    };\r\n    HydraMesh.prototype.updateNormals = function (normals) {\r\n        this._normals = normals.slice(0);\r\n        this.updateOrder(this._normals, \"normal\");\r\n    };\r\n    // This is always called before prims are updated\r\n    HydraMesh.prototype.setMaterial = function (materialId) {\r\n        //console.log(\"Material: \" + materialId);\r\n        if (this._interface.materials[materialId]) {\r\n            this._mesh.material = this._interface.materials[materialId]._material;\r\n        }\r\n    };\r\n    HydraMesh.prototype.setDisplayColor = function (data, interpolation) {\r\n        var wasDefaultMaterial = false;\r\n        if (this._mesh.material === defaultMaterial) {\r\n            this._mesh.material = this._mesh.material.clone();\r\n            wasDefaultMaterial = true;\r\n        }\r\n        this._colors = null;\r\n        if (interpolation === \"constant\") {\r\n            this._mesh.material.color = new THREE.Color().fromArray(data);\r\n        }\r\n        else if (interpolation === \"vertex\") {\r\n            // Per-vertex buffer attribute\r\n            this._mesh.material.vertexColors = true;\r\n            if (wasDefaultMaterial) {\r\n                // Reset the pink debugging color\r\n                this._mesh.material.color = new THREE.Color(0xffffff);\r\n            }\r\n            this._colors = data.slice(0);\r\n            this.updateOrder(this._colors, \"color\");\r\n        }\r\n        else {\r\n            //console.warn(\r\n            // `Unsupported displayColor interpolation type '${interpolation}'.`\r\n            //);\r\n        }\r\n    };\r\n    HydraMesh.prototype.setUV = function (data, dimension, interpolation) {\r\n        // TODO: Support multiple UVs. For now, we simply set uv = uv2, which is required when a material has an aoMap.\r\n        this._uvs = null;\r\n        if (interpolation === \"facevarying\") {\r\n            // The UV buffer has already been prepared on the C++ side, so we just set it\r\n            this._geometry.setAttribute(\"uv\", new THREE.Float32BufferAttribute(data, dimension));\r\n        }\r\n        else if (interpolation === \"vertex\") {\r\n            // We have per-vertex UVs, so we need to sort them accordingly\r\n            this._uvs = data.slice(0);\r\n            this.updateOrder(this._uvs, \"uv\", 2);\r\n        }\r\n        this._geometry.attributes.uv2 = this._geometry.attributes.uv;\r\n    };\r\n    HydraMesh.prototype.updatePrimvar = function (name, data, dimension, interpolation) {\r\n        if (name === \"points\" || name === \"normals\") {\r\n            // Points and normals are set separately\r\n            return;\r\n        }\r\n        //console.log(\"Setting PrimVar: \" + name);\r\n        // TODO: Support multiple UVs. For now, we simply set uv = uv2, which is required when a material has an aoMap.\r\n        if (name.startsWith(\"st\")) {\r\n            name = \"uv\";\r\n        }\r\n        switch (name) {\r\n            case \"displayColor\":\r\n                this.setDisplayColor(data, interpolation);\r\n                break;\r\n            case \"uv\":\r\n                this.setUV(data, dimension, interpolation);\r\n                break;\r\n            default:\r\n            //console.warn(\"Unsupported primvar\", name);\r\n        }\r\n    };\r\n    HydraMesh.prototype.updatePoints = function (points) {\r\n        this._points = points.slice(0);\r\n        this.updateOrder(this._points, \"position\");\r\n    };\r\n    HydraMesh.prototype.commit = function () {\r\n        // Nothing to do here. All Three.js resources are already updated during the sync phase.\r\n    };\r\n    return HydraMesh;\r\n}());\r\nvar defaultMaterial;\r\nvar HydraMaterial = /** @class */ (function () {\r\n    function HydraMaterial(id, hydraInterface) {\r\n        this._id = id;\r\n        this._nodes = {};\r\n        this._interface = hydraInterface;\r\n        if (!defaultMaterial) {\r\n            defaultMaterial = new THREE.MeshPhysicalMaterial({\r\n                side: THREE.DoubleSide,\r\n                color: new THREE.Color(0xff2997),\r\n                envMap: window.envMap,\r\n            });\r\n        }\r\n        this._material = defaultMaterial;\r\n    }\r\n    HydraMaterial.prototype.updateNode = function (networkId, path, parameters) {\r\n        //console.log(\"Updating Material Node: \" + networkId + \" \" + path);\r\n        this._nodes[path] = parameters;\r\n    };\r\n    HydraMaterial.prototype.assignTexture = function (mainMaterial, parameterName) {\r\n        var _this = this;\r\n        var materialParameterMapName = HydraMaterial.usdPreviewToMeshPhysicalTextureMap[parameterName];\r\n        if (materialParameterMapName === undefined) {\r\n            //console.warn(\r\n            //  `Unsupported material texture parameter '${parameterName}'.`\r\n            //);\r\n            return;\r\n        }\r\n        if (mainMaterial[parameterName] && mainMaterial[parameterName].nodeIn) {\r\n            var textureFileName_1 = mainMaterial[parameterName].nodeIn.file;\r\n            var channel_1 = mainMaterial[parameterName].inputName;\r\n            // For debugging\r\n            var matName = Object.keys(this._nodes).find(function (key) { return _this._nodes[key] === mainMaterial; });\r\n            //console.log(\r\n            //  `Setting texture '${materialParameterMapName}' (${textureFileName}) of material '${matName}'...`\r\n            //);\r\n            this._interface.registry.getTexture(textureFileName_1).then(function (texture) {\r\n                var _a, _b;\r\n                if (materialParameterMapName === \"alphaMap\") {\r\n                    // If this is an opacity map, check if it's using the alpha channel of the diffuse map.\r\n                    // If so, simply change the format of that diffuse map to RGBA and make the material transparent.\r\n                    // If not, we need to copy the alpha channel into a new texture's green channel, because that's what Three.js\r\n                    // expects for alpha maps (not supported at the moment).\r\n                    // NOTE that this only works if diffuse maps are always set before opacity maps, so the order of\r\n                    // 'assingTexture' calls for a material matters.\r\n                    if (textureFileName_1 === ((_b = (_a = mainMaterial.diffuseColor) === null || _a === void 0 ? void 0 : _a.nodeIn) === null || _b === void 0 ? void 0 : _b.file) &&\r\n                        channel_1 === \"a\") {\r\n                        _this._material.map.format = THREE.RGBAFormat;\r\n                    }\r\n                    else {\r\n                        // TODO: Extract the alpha channel into a new RGB texture.\r\n                    }\r\n                    _this._material.transparent = true;\r\n                    _this._material.needsUpdate = true;\r\n                    return;\r\n                }\r\n                else if (materialParameterMapName === \"metalnessMap\") {\r\n                    _this._material.metalness = 1.0;\r\n                }\r\n                else if (materialParameterMapName === \"emissiveMap\") {\r\n                    _this._material.emissive = new THREE.Color(0xffffff);\r\n                }\r\n                else if (!HydraMaterial.channelMap[channel_1]) {\r\n                    //console.warn(`Unsupported texture channel '${channel}'!`);\r\n                    return;\r\n                }\r\n                // Clone texture and set the correct format.\r\n                var clonedTexture = texture.clone();\r\n                clonedTexture.format = HydraMaterial.channelMap[channel_1];\r\n                clonedTexture.needsUpdate = true;\r\n                clonedTexture.wrapS = THREE.RepeatWrapping;\r\n                clonedTexture.wrapT = THREE.RepeatWrapping;\r\n                _this._material[materialParameterMapName] = clonedTexture;\r\n                _this._material.needsUpdate = true;\r\n            });\r\n        }\r\n        else {\r\n            this._material[materialParameterMapName] = undefined;\r\n        }\r\n    };\r\n    HydraMaterial.prototype.assignProperty = function (mainMaterial, parameterName) {\r\n        var materialParameterName = HydraMaterial.usdPreviewToMeshPhysicalMap[parameterName];\r\n        if (materialParameterName === undefined) {\r\n            //console.warn(`Unsupported material parameter '${parameterName}'.`);\r\n            return;\r\n        }\r\n        if (mainMaterial[parameterName] !== undefined &&\r\n            !mainMaterial[parameterName].nodeIn) {\r\n            //console.log(\r\n            //  `Assigning property ${parameterName}: ${mainMaterial[parameterName]}`\r\n            //);\r\n            if (Array.isArray(mainMaterial[parameterName])) {\r\n                this._material[materialParameterName] = new THREE.Color().fromArray(mainMaterial[parameterName]);\r\n            }\r\n            else {\r\n                this._material[materialParameterName] = mainMaterial[parameterName];\r\n                if (materialParameterName === \"opacity\" &&\r\n                    mainMaterial[parameterName] < 1.0) {\r\n                    this._material.transparent = true;\r\n                }\r\n            }\r\n        }\r\n    };\r\n    HydraMaterial.prototype.updateFinished = function (type, relationships) {\r\n        for (var _i = 0, relationships_1 = relationships; _i < relationships_1.length; _i++) {\r\n            var relationship = relationships_1[_i];\r\n            relationship.nodeIn = this._nodes[relationship.inputId];\r\n            relationship.nodeOut = this._nodes[relationship.outputId];\r\n            relationship.nodeIn[relationship.inputName] = relationship;\r\n            relationship.nodeOut[relationship.outputName] = relationship;\r\n        }\r\n        //console.log(\"Finalizing Material: \" + this._id);\r\n        // find the main material node\r\n        var mainMaterialNode = undefined;\r\n        for (var _a = 0, _b = Object.values(this._nodes); _a < _b.length; _a++) {\r\n            var node = _b[_a];\r\n            if (node.diffuseColor) {\r\n                mainMaterialNode = node;\r\n                break;\r\n            }\r\n        }\r\n        if (!mainMaterialNode) {\r\n            this._material = defaultMaterial;\r\n            return;\r\n        }\r\n        // TODO: Ideally, we don't recreate the material on every update.\r\n        // Creating a new one requires to also update any meshes that reference it. So we're relying on the C++ side to\r\n        // call this before also calling `setMaterial` on the affected meshes.\r\n        //console.log(\"Creating Material: \" + this._id);\r\n        this._material = new THREE.MeshPhysicalMaterial({});\r\n        // Assign textures\r\n        for (var key in HydraMaterial.usdPreviewToMeshPhysicalTextureMap) {\r\n            this.assignTexture(mainMaterialNode, key);\r\n        }\r\n        // Assign material properties\r\n        for (var key in HydraMaterial.usdPreviewToMeshPhysicalMap) {\r\n            this.assignProperty(mainMaterialNode, key);\r\n        }\r\n        if (window.envMap) {\r\n            this._material.envMap = window.envMap;\r\n        }\r\n        //console.log(this._material);\r\n    };\r\n    // Maps USD preview material texture names to Three.js MeshPhysicalMaterial names\r\n    HydraMaterial.usdPreviewToMeshPhysicalTextureMap = {\r\n        diffuseColor: \"map\",\r\n        clearcoat: \"clearcoatMap\",\r\n        clearcoatRoughness: \"clearcoatRoughnessMap\",\r\n        emissiveColor: \"emissiveMap\",\r\n        occlusion: \"aoMap\",\r\n        roughness: \"roughnessMap\",\r\n        metallic: \"metalnessMap\",\r\n        normal: \"normalMap\",\r\n        opacity: \"alphaMap\",\r\n    };\r\n    HydraMaterial.channelMap = {\r\n        // Three.js expects many 8bit values such as roughness or metallness in a specific RGB texture channel.\r\n        // We could write code to combine multiple 8bit texture files into different channels of one RGB texture where it\r\n        // makes sense, but that would complicate this loader a lot. Most Three.js loaders don't seem to do it either.\r\n        // Instead, we simply provide the 8bit image as an RGB texture, even though this might be less efficient.\r\n        r: THREE.RGBAFormat,\r\n        rgb: THREE.RGBAFormat,\r\n        rgba: THREE.RGBAFormat,\r\n    };\r\n    // Maps USD preview material property names to Three.js MeshPhysicalMaterial names\r\n    HydraMaterial.usdPreviewToMeshPhysicalMap = {\r\n        clearcoat: \"clearcoat\",\r\n        clearcoatRoughness: \"clearcoatRoughness\",\r\n        diffuseColor: \"color\",\r\n        emissiveColor: \"emissive\",\r\n        ior: \"ior\",\r\n        metallic: \"metalness\",\r\n        opacity: \"opacity\",\r\n        roughness: \"roughness\",\r\n    };\r\n    return HydraMaterial;\r\n}());\r\nvar RenderDelegateInterface = /** @class */ (function () {\r\n    function RenderDelegateInterface(filename, usdRoot) {\r\n        this.registry = new TextureRegistry(filename);\r\n        this.materials = {};\r\n        this.meshes = {};\r\n        window.usdRoot = usdRoot;\r\n    }\r\n    RenderDelegateInterface.prototype.createRPrim = function (typeId, id, instancerId) {\r\n        //console.log(\"Creating RPrim: \" + typeId + \" \" + id);\r\n        var mesh = new HydraMesh(id, this);\r\n        this.meshes[id] = mesh;\r\n        return mesh;\r\n    };\r\n    RenderDelegateInterface.prototype.createBPrim = function (typeId, id) {\r\n        //console.log(\"Creating BPrim: \" + typeId + \" \" + id);\r\n        /*let mesh = new HydraMesh(id, this);\r\n        this.meshes[id] = mesh;\r\n        return mesh;*/\r\n    };\r\n    RenderDelegateInterface.prototype.createSPrim = function (typeId, id) {\r\n        //console.log(\"Creating SPrim: \" + typeId + \" \" + id);\r\n        if (typeId === \"material\") {\r\n            var material = new HydraMaterial(id, this);\r\n            this.materials[id] = material;\r\n            return material;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    };\r\n    RenderDelegateInterface.prototype.setDriver = function (driver) {\r\n        window.driver = driver;\r\n    };\r\n    RenderDelegateInterface.prototype.CommitResources = function () {\r\n        for (var id in this.meshes) {\r\n            var hydraMesh = this.meshes[id];\r\n            hydraMesh.commit();\r\n        }\r\n    };\r\n    return RenderDelegateInterface;\r\n}());\r\nexports.RenderDelegateInterface = RenderDelegateInterface;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}